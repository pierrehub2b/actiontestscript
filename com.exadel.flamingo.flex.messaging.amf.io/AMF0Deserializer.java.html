<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AMF0Deserializer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ats-automated-testing</a> &gt; <a href="index.source.html" class="el_package">com.exadel.flamingo.flex.messaging.amf.io</a> &gt; <span class="el_source">AMF0Deserializer.java</span></div><h1>AMF0Deserializer.java</h1><pre class="source lang-java linenums">/*
 * www.openamf.org
 *
 * Distributable under LGPL license.
 * See terms of license at gnu.org.
 */

package com.exadel.flamingo.flex.messaging.amf.io;

import com.exadel.flamingo.flex.amf.AMF0Body;
import com.exadel.flamingo.flex.amf.AMF0Message;
import flex.messaging.io.ASObject;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.Document;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import java.io.*;
import java.util.*;

public class AMF0Deserializer {

<span class="nc" id="L25">    private static Log log = LogFactory.getLog(AMF0Deserializer.class);</span>

<span class="nc" id="L27">    private List&lt;Object&gt; storedObjects = null;</span>

    /**
     * The AMF input stream
     */
    protected DataInputStream inputStream;

    /**
     * Number of headers in the packet
     */
    protected int headerCount;

    /**
     * Content of the headers
     */
<span class="nc" id="L42">    protected List&lt;?&gt; headers = new ArrayList&lt;Object&gt;();</span>

    /**
     * Number of bodies
     */
    protected int bodyCount;

    /**
     * Content of the bodies
     */
<span class="nc" id="L52">    protected List&lt;?&gt; bodies = new ArrayList&lt;Object&gt;();</span>

    /**
     * Object to store the deserialized data
     */
<span class="nc" id="L57">    protected AMF0Message message = new AMF0Message();</span>
    
<span class="nc" id="L59">    public AMF0Deserializer(DataInputStream inputStream) throws IOException {</span>
        //if (log.isInfoEnabled()) log.info(&quot;Deserializing Message, for more info turn on debug level&quot;);

        // Save the input stream for this object
<span class="nc" id="L63">        this.inputStream = inputStream;</span>
        
        // Read the binary header
<span class="nc" id="L66">        readHeaders();</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;readHeader&quot;);</span>
        // Read the binary body
<span class="nc" id="L69">        readBodies();</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;readBody&quot;);</span>
<span class="nc" id="L71">    }</span>

    public AMF0Message getAMFMessage() {
<span class="nc" id="L74">        return message;</span>
    }

    protected void readHeaders() throws IOException {
        // version
<span class="nc" id="L79">        message.setVersion(inputStream.readUnsignedShort());</span>
        // Find total number of header elements
<span class="nc" id="L81">        headerCount = inputStream.readUnsignedShort();</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;headerCount = &quot; + headerCount);</span>
        // Loop over all the header elements
<span class="nc bnc" id="L84" title="All 2 branches missed.">        for (int i = 0; i &lt; headerCount; i++) {</span>
            // clear storedObjects - references are new for every header
<span class="nc" id="L86">            storedObjects = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L87">            String key = inputStream.readUTF();</span>
            // Find the must understand flag
<span class="nc" id="L89">            boolean required = inputStream.readBoolean();</span>
            // Grab the length of the header element
<span class="nc" id="L91">            /*long length =*/ inputStream.readInt();</span>
            // Grab the type of the element
<span class="nc" id="L93">            byte type = inputStream.readByte();</span>
            // Turn the element into real data
<span class="nc" id="L95">            Object value = readData(type);</span>
            // Save the name/value into the headers array
<span class="nc" id="L97">            message.addHeader(key, required, value);</span>
        }
<span class="nc" id="L99">    }</span>

    protected void readBodies() throws IOException {
        // Find the total number of body elements
<span class="nc" id="L103">        bodyCount = inputStream.readUnsignedShort();</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;bodyCount = &quot; + bodyCount);</span>

        // Loop over all the body elements
<span class="nc bnc" id="L107" title="All 2 branches missed.">        for (int i = 0; i &lt; bodyCount; i++) {</span>
            //clear storedObjects
<span class="nc" id="L109">            storedObjects = new ArrayList&lt;Object&gt;();</span>
            // The target method
<span class="nc" id="L111">            String method = inputStream.readUTF();</span>
            // The target that the client understands
<span class="nc" id="L113">            String target = inputStream.readUTF();</span>
            // Get the length of the body element
<span class="nc" id="L115">            /*long length =*/ inputStream.readInt();</span>
            // Grab the type of the element
<span class="nc" id="L117">            byte type = inputStream.readByte();</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">            if (log.isDebugEnabled()) log.debug(&quot;type = &quot; + type);</span>
            // Turn the argument elements into real data
<span class="nc" id="L120">            Object data = readData(type);</span>
            // Add the body element to the body object
<span class="nc" id="L122">            message.addBody(method, target, data, type);</span>
        }
<span class="nc" id="L124">    }</span>

    protected Object readCustomClass() throws IOException {
        // Grab the explicit type - somehow it works
<span class="nc" id="L128">        String type = inputStream.readUTF();</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;Reading Custom Class: &quot; + type);</span>
        /*
        String mappedJavaClass = OpenAMFConfig.getInstance().getJavaClassName(type);
        if (mappedJavaClass != null) {
            type = mappedJavaClass;
        }
        */
<span class="nc" id="L136">        ASObject aso = new ASObject(type);</span>
        // The rest of the bytes are an object without the 0x03 header
<span class="nc" id="L138">        return readObject(aso);</span>
    }

    protected ASObject readObject() throws IOException {
<span class="nc" id="L142">        ASObject aso = new ASObject();</span>
<span class="nc" id="L143">        return readObject(aso);</span>
    }

    protected ASObject readObject(ASObject aso) throws IOException {
<span class="nc" id="L147">        storeObject(aso);</span>
        // Init the array
<span class="nc bnc" id="L149" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;reading object&quot;);</span>
        // Grab the key
<span class="nc" id="L151">        String key = inputStream.readUTF();</span>
<span class="nc" id="L152">        for (byte type = inputStream.readByte();</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">             type != 9;</span>
<span class="nc" id="L154">             type = inputStream.readByte()) {</span>
            // Grab the value
<span class="nc" id="L156">            Object value = readData(type);</span>
            // Save the name/value pair in the map
<span class="nc bnc" id="L158" title="All 2 branches missed.">            if (value == null) {</span>
<span class="nc" id="L159">                log.info(&quot;Skipping NULL value for :&quot; + key);</span>
            } else {
<span class="nc" id="L161">                aso.put(key, value);</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">                if (log.isDebugEnabled()) log.debug(&quot; adding {key=&quot; + key + &quot;, value=&quot; + value + &quot;, type=&quot; + type + &quot;}&quot;);</span>
            }
            // Get the next name
<span class="nc" id="L165">            key = inputStream.readUTF();</span>
        }
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;finished reading object&quot;);</span>
        // Return the map
<span class="nc" id="L169">        return aso;</span>
    }

    protected List&lt;?&gt; readArray() throws IOException {
        // Init the array
<span class="nc" id="L174">        List&lt;Object&gt; array = new ArrayList&lt;Object&gt;();</span>
<span class="nc" id="L175">        storeObject(array);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;Reading array&quot;);</span>
        // Grab the length of the array
<span class="nc" id="L178">        long length = inputStream.readInt();</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;array length = &quot; + length);</span>
        // Loop over all the elements in the data
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (long i = 0; i &lt; length; i++) {</span>
            // Grab the type for each element
<span class="nc" id="L183">            byte type = inputStream.readByte();</span>
            // Grab the element
<span class="nc" id="L185">            Object data = readData(type);</span>
<span class="nc" id="L186">            array.add(data);</span>
        }
        // Return the data
<span class="nc" id="L189">        return array;</span>
    }

    private void storeObject(Object o) {
<span class="nc" id="L193">        storedObjects.add(o);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;storedObjects.size: &quot; + storedObjects.size());</span>
<span class="nc" id="L195">    }</span>

    protected Date readDate() throws IOException {
<span class="nc" id="L198">        long ms = (long) inputStream.readDouble(); // Date in millis from 01/01/1970</span>

      // here we have to read in the raw
      // timezone offset (which comes in minutes, but incorrectly signed),
      // make it millis, and fix the sign.
<span class="nc" id="L203">      int timeoffset = inputStream.readShort() * 60000 * -1; // now we have millis</span>

<span class="nc" id="L205">      TimeZone serverTimeZone = TimeZone.getDefault();</span>

      // now we subtract the current timezone offset and add the one that was passed
      // in (which is of the Flash client), which gives us the appropriate ms (i think)
      // -alon
<span class="nc" id="L210">      Calendar sent = new GregorianCalendar();</span>
<span class="nc" id="L211">      sent.setTime( (new Date(ms - serverTimeZone.getRawOffset() + timeoffset)));</span>

<span class="nc" id="L213">      TimeZone sentTimeZone = sent.getTimeZone();</span>

      // we have to handle daylight savings ms as well
<span class="nc bnc" id="L216" title="All 2 branches missed.">      if (sentTimeZone.inDaylightTime(sent.getTime()))</span>
      {
          //
          // Implementation note: we are trying to maintain compatibility
          // with J2SE 1.3.1
          //
          // As such, we can't use java.util.Calendar.getDSTSavings() here
          // 
<span class="nc" id="L224">        sent.setTime(new java.util.Date(sent.getTime().getTime() - 3600000));</span>
      }

<span class="nc" id="L227">      return sent.getTime();</span>
    }

    protected Object readFlushedSO() throws IOException {
<span class="nc" id="L231">        int index = inputStream.readUnsignedShort();</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;Object Index: &quot; + index);</span>
<span class="nc" id="L233">        return storedObjects.get(index);</span>
    }

    protected Object readASObject() {
<span class="nc" id="L237">        return null;</span>
    }

    protected Object readAMF3Data() throws IOException {
<span class="nc" id="L241">    	ObjectInput amf3 = new AMF3Deserializer(inputStream);</span>
		
        try {
<span class="nc" id="L244">            return amf3.readObject();</span>
<span class="nc" id="L245">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L246">            throw new RuntimeException(e);</span>
        }
    }

    protected Object readData(byte type) throws IOException {
<span class="nc bnc" id="L251" title="All 2 branches missed.">        if (log.isDebugEnabled()) log.debug(&quot;Reading data of type &quot; + AMF0Body.getObjectTypeDescription(type));</span>
<span class="nc bnc" id="L252" title="All 18 branches missed.">        switch (type) {</span>
            case AMF0Body.DATA_TYPE_NUMBER: // 0
<span class="nc" id="L254">                return new Double(inputStream.readDouble());</span>
            case AMF0Body.DATA_TYPE_BOOLEAN: // 1
<span class="nc" id="L256">                return Boolean.valueOf(inputStream.readBoolean());</span>
            case AMF0Body.DATA_TYPE_STRING: // 2
<span class="nc" id="L258">                return inputStream.readUTF();</span>
            case AMF0Body.DATA_TYPE_OBJECT: // 3
<span class="nc" id="L260">                return readObject();</span>
            case AMF0Body.DATA_TYPE_MOVIE_CLIP: // 4
<span class="nc" id="L262">                throw new IOException(&quot;Unknown/unsupported object type &quot; + AMF0Body.getObjectTypeDescription(type));</span>
            case AMF0Body.DATA_TYPE_NULL: // 5
            case AMF0Body.DATA_TYPE_UNDEFINED: //6
<span class="nc" id="L265">                return null;</span>
            case AMF0Body.DATA_TYPE_REFERENCE_OBJECT: // 7
<span class="nc" id="L267">                return readFlushedSO();</span>
            case AMF0Body.DATA_TYPE_MIXED_ARRAY: // 8
<span class="nc" id="L269">                /*long length =*/ inputStream.readInt();</span>
                //don't do anything with the length
<span class="nc" id="L271">                return readObject();</span>
            case AMF0Body.DATA_TYPE_OBJECT_END: // 9
<span class="nc" id="L273">                return null;</span>
            case AMF0Body.DATA_TYPE_ARRAY: // 10
<span class="nc" id="L275">                return readArray();</span>
            case AMF0Body.DATA_TYPE_DATE: // 11
<span class="nc" id="L277">                return readDate();</span>
            case AMF0Body.DATA_TYPE_LONG_STRING: // 12
<span class="nc" id="L279">                return readLongUTF(inputStream);</span>
            case AMF0Body.DATA_TYPE_AS_OBJECT: // 13
<span class="nc" id="L281">                return readASObject();</span>
            case AMF0Body.DATA_TYPE_RECORDSET: // 14
<span class="nc" id="L283">                return null;</span>
            case AMF0Body.DATA_TYPE_XML: // 15
<span class="nc" id="L285">                return convertToDOM(inputStream);</span>
            case AMF0Body.DATA_TYPE_CUSTOM_CLASS: // 16
<span class="nc" id="L287">                return readCustomClass();</span>
            case AMF0Body.DATA_TYPE_AMF3_OBJECT: // 17
<span class="nc" id="L289">                return readAMF3Data();</span>
            default :
<span class="nc" id="L291">                throw new IOException(&quot;Unknown/unsupported object type &quot; + AMF0Body.getObjectTypeDescription(type));</span>
        }
    }

    private Object readLongUTF(DataInputStream in) throws IOException {
<span class="nc" id="L296">      int utflen = in.readInt();</span>
<span class="nc" id="L297">      StringBuffer str = new StringBuffer(utflen);</span>
<span class="nc" id="L298">      byte bytearr [] = new byte[utflen];</span>
      int c, char2, char3;
<span class="nc" id="L300">      int count = 0;</span>

<span class="nc" id="L302">      in.readFully(bytearr, 0, utflen);</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">      while (count &lt; utflen) {</span>
<span class="nc" id="L305">        c = bytearr[count] &amp; 0xff;</span>
<span class="nc bnc" id="L306" title="All 4 branches missed.">        switch (c &gt;&gt; 4) {</span>
          case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
            /* 0xxxxxxx*/
<span class="nc" id="L309">            count++;</span>
<span class="nc" id="L310">            str.append((char)c);</span>
<span class="nc" id="L311">            break;</span>
          case 12: case 13:
            /* 110x xxxx   10xx xxxx*/
<span class="nc" id="L314">            count += 2;</span>
<span class="nc bnc" id="L315" title="All 2 branches missed.">            if (count &gt; utflen)</span>
<span class="nc" id="L316">              throw new UTFDataFormatException();</span>
<span class="nc" id="L317">            char2 = bytearr[count-1];</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">            if ((char2 &amp; 0xC0) != 0x80)</span>
<span class="nc" id="L319">              throw new UTFDataFormatException(); </span>
<span class="nc" id="L320">            str.append((char)(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F)));</span>
<span class="nc" id="L321">              break;</span>
          case 14:
            /* 1110 xxxx  10xx xxxx  10xx xxxx */
<span class="nc" id="L324">            count += 3;</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">            if (count &gt; utflen)</span>
<span class="nc" id="L326">              throw new UTFDataFormatException();</span>
<span class="nc" id="L327">            char2 = bytearr[count-2];</span>
<span class="nc" id="L328">            char3 = bytearr[count-1];</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">            if (((char2 &amp; 0xC0) != 0x80) || ((char3 &amp; 0xC0) != 0x80))</span>
<span class="nc" id="L330">              throw new UTFDataFormatException();   </span>
<span class="nc" id="L331">            str.append((char)(((c     &amp; 0x0F) &lt;&lt; 12) |</span>
                              ((char2 &amp; 0x3F) &lt;&lt; 6)  |
                              ((char3 &amp; 0x3F) &lt;&lt; 0)));
<span class="nc" id="L334">            break;</span>
          default:
            /* 10xx xxxx,  1111 xxxx */
<span class="nc" id="L337">            throw new UTFDataFormatException();     </span>
        }
      }

      // The number of chars produced may be less than utflen
<span class="nc" id="L342">      return new String(str);</span>
    }
    
    public static Document convertToDOM(InputStream is) throws IOException {
<span class="nc" id="L346">        Document document = null;</span>
<span class="nc" id="L347">        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</span>
<span class="nc" id="L348">        is.skip(4); // skip length</span>
        try {
<span class="nc" id="L350">            DocumentBuilder builder = factory.newDocumentBuilder();</span>
<span class="nc" id="L351">            document = builder.parse(new InputSource(is));</span>
<span class="nc" id="L352">        } catch (Exception e) {</span>
<span class="nc" id="L353">            log.error(e, e);</span>
<span class="nc" id="L354">            throw new IOException(&quot;Error while parsing xml: &quot; + e.getMessage());</span>
<span class="nc" id="L355">        }</span>
<span class="nc" id="L356">        return document;</span>
    }
    
    //private static final String data1 = &quot;00 03 00 00 00 01 00 04 6E 75 6C 6C 00 02 2F 31 00 00 00 D1 0A 00 00 00 01 11 0A 81 23 4D 66 6C 65 78 2E 6D 65 73 73 61 67 69 6E 67 2E 6D 65 73 73 61 67 65 73 2E 43 6F 6D 6D 61 6E 64 4D 65 73 73 61 67 65 13 6F 70 65 72 61 74 69 6F 6E 1D 6D 65 73 73 61 67 65 52 65 66 54 79 70 65 1B 63 6F 72 72 65 6C 61 74 69 6F 6E 49 64 11 63 6C 69 65 6E 74 49 64 15 74 69 6D 65 54 6F 4C 69 76 65 13 6D 65 73 73 61 67 65 49 64 0F 68 65 61 64 65 72 73 13 74 69 6D 65 73 74 61 6D 70 09 62 6F 64 79 17 64 65 73 74 69 6E 61 74 69 6F 6E 04 05 01 06 01 01 04 00 06 49 38 31 45 34 34 39 33 33 2D 43 35 35 34 2D 43 33 33 46 2D 41 37 37 34 2D 43 33 36 44 46 36 30 44 33 39 32 36 0A 0B 01 01 04 00 0A 05 01 06 01&quot;;
    //private static final String data1 = &quot;00 03 00 00 00 01 00 0B 2F 31 2F 6F 6E 52 65 73 75 6C 74 00 00 FF FF FF FF 11 0A 81 03 55 66 6C 65 78 2E 6D 65 73 73 61 67 69 6E 67 2E 6D 65 73 73 61 67 65 73 2E 41 63 6B 6E 6F 77 6C 65 64 67 65 4D 65 73 73 61 67 65 17 64 65 73 74 69 6E 61 74 69 6F 6E 0F 68 65 61 64 65 72 73 1B 63 6F 72 72 65 6C 61 74 69 6F 6E 49 64 13 6D 65 73 73 61 67 65 49 64 13 74 69 6D 65 73 74 61 6D 70 11 63 6C 69 65 6E 74 49 64 15 74 69 6D 65 54 6F 4C 69 76 65 09 62 6F 64 79 01 01 06 49 63 38 34 39 32 32 39 39 2D 36 34 66 39 2D 34 66 34 30 2D 38 66 38 35 2D 39 38 31 30 33 34 30 64 34 37 32 33 06 49 62 39 32 33 38 30 33 32 2D 64 65 30 63 2D 34 30 36 35 2D 62 36 31 65 2D 35 66 33 64 34 30 34 61 32 64 32 36 08 01 00 00 01 0E D8 09 B4 8D 06 49 36 31 33 38 35 65 61 31 2D 66 66 35 36 2D 34 35 32 37 2D 39 65 35 66 2D 34 33 39 66 62 37 36 38 39 32 39 31 04 00 01&quot;;
    private static final String data1   = &quot;00 03 00 00 00 01 00 04 6E 75 6C 6C 00 02 2F 33 00 00 00 92 0A 00 00 00 01 11 0A 81 13 4F 66 6C 65 78 2E 6D 65 73 73 61 67 69 6E 67 2E 6D 65 73 73 61 67 65 73 2E 52 65 6D 6F 74 69 6E 67 4D 65 73 73 61 67 65 0D 73 6F 75 72 63 65 13 6F 70 65 72 61 74 69 6F 6E 09 62 6F 64 79 17 64 65 73 74 69 6E 61 74 69 6F 6E 11 63 6C 69 65 6E 74 49 64 15 74 69 6D 65 54 6F 4C 69 76 65 13 6D 65 73 73 61 67 65 49 64 0F 68 65 61 64 65 72 73 13 74 69 6D 65 73 74 61 6D 70 01 06 0D 75 70 64 61 74 65 09 03 01 0A 73 39 66 6C 65 78 2E 74 65 73 74 64 72 69 76 65 2E 73 74 6F 72 65 2E 50 72 6F 64 75 63 74 09 6E 61 6D 65 0B 70 72 69 63 65 0B 69 6D 61 67 65 11 63 61 74 65 67 6F 72 79 07 75 69 64 13 70 72 6F 64 75 63 74 49 64 17 64 65 73 63 72 69 70 74 69 6F 6E 06 0D 70 72 6F 64 20 33 05 40 12 3D 70 A3 D7 0A 3D 06 13 70 72 6F 64 33 2E 70 6E 67 06 17 70 72 6F 64 75 63 74 20 63 61 74 06 49 33 41 44 38 35 46 34 37 2D 31 35 33 36 2D 42 38 34 46 2D 36 36 34 42 2D 30 31 41 30 37 45 30 32 38 34 39 31 04 03 06 25 70 72 6F 64 20 64 65 73 63 72 69 70 74 69 6F 6E 20 33 06 0F 70 72 6F 64 75 63 74 01 04 00 06 49 37 32 31 32 39 46 38 37 2D 45 41 45 46 2D 35 46 37 35 2D 41 37 37 30 2D 30 31 41 30 41 35 45 43 42 37 34 32 0A 0B 01 15 44 53 45 6E 64 70 6F 69 6E 74 06 0D 6D 79 2D 61 6D 66 01 04 00&quot;;
    //private static final String data1   = &quot;00 03 00 00 00 01 00 0B 2F 32 2F 6F 6E 52 65 73 75 6C 74 00 00 FF FF FF FF 11 0A 81 03 55 66 6C 65 78 2E 6D 65 73 73 61 67 69 6E 67 2E 6D 65 73 73 61 67 65 73 2E 41 63 6B 6E 6F 77 6C 65 64 67 65 4D 65 73 73 61 67 65 09 62 6F 64 79 11 63 6C 69 65 6E 74 49 64 1B 63 6F 72 72 65 6C 61 74 69 6F 6E 49 64 17 64 65 73 74 69 6E 61 74 69 6F 6E 0F 68 65 61 64 65 72 73 13 6D 65 73 73 61 67 65 49 64 15 74 69 6D 65 54 6F 4C 69 76 65 13 74 69 6D 65 73 74 61 6D 70 0A 07 43 66 6C 65 78 2E 6D 65 73 73 61 67 69 6E 67 2E 69 6F 2E 41 72 72 61 79 43 6F 6C 6C 65 63 74 69 6F 6E 09 03 01 0A 63 39 66 6C 65 78 2E 74 65 73 74 64 72 69 76 65 2E 73 74 6F 72 65 2E 50 72 6F 64 75 63 74 11 63 61 74 65 67 6F 72 79 17 64 65 73 63 72 69 70 74 69 6F 6E 0B 69 6D 61 67 65 09 6E 61 6D 65 0B 70 72 69 63 65 13 70 72 6F 64 75 63 74 49 64 06 17 70 72 6F 64 75 63 74 20 63 61 74 06 25 70 72 6F 64 20 64 65 73 63 72 69 70 74 69 6F 6E 20 31 06 13 70 72 6F 64 31 2E 70 6E 67 06 0D 70 72 6F 64 20 31 05 40 16 3D 70 A3 D7 0A 3D 04 01 06 49 34 61 64 65 63 36 65 31 2D 35 37 66 61 2D 34 32 61 38 2D 38 35 36 38 2D 65 65 39 62 37 64 65 38 35 32 65 35 06 49 38 46 36 36 39 31 32 39 2D 39 44 46 35 2D 44 34 31 31 2D 31 36 34 31 2D 30 31 33 35 37 39 37 41 37 37 39 43 01 01 06 49 38 36 61 38 66 32 31 36 2D 35 34 34 34 2D 34 34 36 30 2D 39 33 37 37 2D 39 64 37 62 37 62 65 34 65 64 32 61 04 00 08 01 42 70 F0 13 81 5B 20 00&quot;;
    
    public static void main(String[] args) throws Exception {
<span class="nc" id="L365">        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(toByteArray(data1)));</span>
        
<span class="nc" id="L367">        AMF0Deserializer des = new AMF0Deserializer(dis);</span>
<span class="nc" id="L368">        System.out.println(des.getAMFMessage().toString());</span>
<span class="nc" id="L369">    }</span>
    
    private static byte[] toByteArray(String hex) {
<span class="nc" id="L372">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L373">        String[] toks = hex.split(&quot; &quot;);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">        for (int i = 0; i &lt; toks.length; i++)</span>
<span class="nc" id="L375">            baos.write(Integer.parseInt(toks[i], 16));</span>
<span class="nc" id="L376">        return baos.toByteArray();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>